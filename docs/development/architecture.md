# ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

voidVM é‡‡ç”¨å‰åç«¯åˆ†ç¦»çš„ç°ä»£åŒ–æ¶æ„ï¼Œé€šè¿‡å¾®æœåŠ¡è®¾è®¡å®ç°é«˜å¯ç”¨ã€å¯æ‰©å±•çš„è™šæ‹Ÿæœºç®¡ç†å¹³å°ã€‚

## æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Web Browser   â”‚    â”‚   Mobile App    â”‚    â”‚   Desktop App   â”‚
â”‚    (Vue)        â”‚    â”‚    (Future)     â”‚    â”‚    (Future)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Load Balancer         â”‚
                    â”‚       (Nginx)              â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Gateway   â”‚    â”‚   Static Files  â”‚    â”‚   WebSocket     â”‚
â”‚   (Express.js)  â”‚    â”‚    (Assets)     â”‚    â”‚   (Socket.io)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Backend Services                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    VM       â”‚  â”‚   Auth      â”‚  â”‚ Monitoring  â”‚             â”‚
â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Image     â”‚  â”‚   Network   â”‚  â”‚   Storage   â”‚             â”‚
â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Supabase      â”‚    â”‚     QEMU        â”‚    â”‚    Host OS      â”‚
â”‚  (Database)     â”‚    â”‚  Hypervisor     â”‚    â”‚   Resources     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## å‰ç«¯æ¶æ„ (Vue)

```
Frontend Architecture
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/          # å¯å¤ç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ common/         # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ Loading.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ Modal.vue
â”‚   â”‚   â”‚   â””â”€â”€ Toast.vue
â”‚   â”‚   â”œâ”€â”€ vm/             # è™šæ‹Ÿæœºç›¸å…³ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ VMCard.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ VMConsole.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ VMMetrics.vue
â”‚   â”‚   â”‚   â””â”€â”€ VMSettings.vue
â”‚   â”‚   â””â”€â”€ layout/         # å¸ƒå±€ç»„ä»¶
â”‚   â”‚       â”œâ”€â”€ Header.vue
â”‚   â”‚       â”œâ”€â”€ Sidebar.vue
â”‚   â”‚       â””â”€â”€ Footer.vue
â”‚   â”œâ”€â”€ views/              # é¡µé¢è§†å›¾
â”‚   â”‚   â”œâ”€â”€ Dashboard.vue
â”‚   â”‚   â”œâ”€â”€ VMList.vue
â”‚   â”‚   â”œâ”€â”€ VMDetail.vue
â”‚   â”‚   â””â”€â”€ Settings.vue
â”‚   â”œâ”€â”€ stores/             # Pinia çŠ¶æ€ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”œâ”€â”€ vm.js
â”‚   â”‚   â””â”€â”€ ui.js
â”‚   â”œâ”€â”€ composables/        # ç»„åˆå¼å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ useAuth.js
â”‚   â”‚   â”œâ”€â”€ useVM.js
â”‚   â”‚   â””â”€â”€ useWebSocket.js
â”‚   â”œâ”€â”€ services/           # API æœåŠ¡å±‚
â”‚   â”‚   â”œâ”€â”€ api.js
â”‚   â”‚   â”œâ”€â”€ vmService.js
â”‚   â”‚   â””â”€â”€ authService.js
â”‚   â””â”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ constants.js
â”‚       â”œâ”€â”€ helpers.js
â”‚       â””â”€â”€ validators.js
```

**å‰ç«¯æŠ€æœ¯é€‰å‹**:

- **Vue**: é‡‡ç”¨ Composition APIï¼Œæä¾›æ›´å¥½çš„é€»è¾‘å¤ç”¨å’Œç±»å‹æ¨æ–­
- **Vue Router**: å•é¡µé¢åº”ç”¨è·¯ç”±ç®¡ç†
- **Pinia**: ç°ä»£åŒ–çŠ¶æ€ç®¡ç†ï¼Œæ›¿ä»£ Vuex
- **Vite**: å¿«é€Ÿçš„æ„å»ºå·¥å…·å’Œå¼€å‘æœåŠ¡å™¨
- **BootStrap**: UI ç»„ä»¶åº“
- **Socket.io Client**: å®æ—¶é€šä¿¡

## åç«¯æ¶æ„ (Node.js)

```
Backend Architecture
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ routes/              # è·¯ç”±å±‚
â”‚   â”‚   â”œâ”€â”€ auth.js         # è®¤è¯è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ vms.js          # è™šæ‹Ÿæœºè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ images.js       # é•œåƒè·¯ç”±
â”‚   â”‚   â””â”€â”€ monitoring.js   # ç›‘æ§è·¯ç”±
â”‚   â”œâ”€â”€ controllers/         # æ§åˆ¶å™¨å±‚
â”‚   â”‚   â”œâ”€â”€ AuthController.js
â”‚   â”‚   â”œâ”€â”€ VMController.js
â”‚   â”‚   â”œâ”€â”€ ImageController.js
â”‚   â”‚   â””â”€â”€ MonitoringController.js
â”‚   â”œâ”€â”€ services/            # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â”œâ”€â”€ VMService.js     # è™šæ‹ŸæœºæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ QEMUService.js   # QEMU ç®¡ç†æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ AuthService.js   # è®¤è¯æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ ImageService.js  # é•œåƒç®¡ç†æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ NetworkService.js # ç½‘ç»œç®¡ç†æœåŠ¡
â”‚   â”‚   â””â”€â”€ StorageService.js # å­˜å‚¨ç®¡ç†æœåŠ¡
â”‚   â”œâ”€â”€ middleware/          # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ auth.js         # è®¤è¯ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ validation.js   # å‚æ•°éªŒè¯
â”‚   â”‚   â”œâ”€â”€ rateLimiter.js  # é™æµä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ errorHandler.js # é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ VM.js
â”‚   â”‚   â”œâ”€â”€ User.js
â”‚   â”‚   â””â”€â”€ Image.js
â”‚   â”œâ”€â”€ utils/               # å·¥å…·ç±»
â”‚   â”‚   â”œâ”€â”€ qemuWrapper.js  # QEMU å‘½ä»¤å°è£…
â”‚   â”‚   â”œâ”€â”€ logger.js       # æ—¥å¿—å·¥å…·
â”‚   â”‚   â””â”€â”€ validators.js   # éªŒè¯å·¥å…·
â”‚   â””â”€â”€ config/              # é…ç½®æ–‡ä»¶
â”‚       â”œâ”€â”€ database.js     # æ•°æ®åº“é…ç½®
â”‚       â”œâ”€â”€ qemu.js         # QEMU é…ç½®
â”‚       â””â”€â”€ supabase.js     # Supabase é…ç½®
```

**åç«¯æŠ€æœ¯é€‰å‹**:

- **Express.js**: Web æ¡†æ¶
- **Socket.io**: WebSocket å®æ—¶é€šä¿¡
- **Joi**: å‚æ•°éªŒè¯
- **Winston**: æ—¥å¿—è®°å½•
- **Node-cron**: å®šæ—¶ä»»åŠ¡
- **Multer**: æ–‡ä»¶ä¸Šä¼ å¤„ç†

## æ•°æ®åº“è®¾è®¡ (Supabase/PostgreSQL)

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    avatar_url TEXT,
    role VARCHAR(20) DEFAULT 'user',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- è™šæ‹Ÿæœºè¡¨
CREATE TABLE virtual_machines (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'stopped', -- stopped, running, paused, error
    cpu_cores INTEGER DEFAULT 1,
    memory_mb INTEGER DEFAULT 1024,
    disk_size_gb INTEGER DEFAULT 20,
    os_type VARCHAR(50),
    image_id UUID REFERENCES vm_images(id),
    network_config JSONB,
    qemu_config JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- è™šæ‹Ÿæœºé•œåƒè¡¨
CREATE TABLE vm_images (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    os_type VARCHAR(50),
    version VARCHAR(50),
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    checksum VARCHAR(64),
    is_public BOOLEAN DEFAULT false,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- è™šæ‹Ÿæœºç›‘æ§æ•°æ®è¡¨
CREATE TABLE vm_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    vm_id UUID REFERENCES virtual_machines(id) ON DELETE CASCADE,
    cpu_usage DECIMAL(5,2),
    memory_usage DECIMAL(5,2),
    disk_usage DECIMAL(5,2),
    network_in_bytes BIGINT,
    network_out_bytes BIGINT,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æ“ä½œæ—¥å¿—è¡¨
CREATE TABLE operation_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    vm_id UUID REFERENCES virtual_machines(id),
    operation VARCHAR(50), -- create, start, stop, delete, etc.
    status VARCHAR(20), -- success, failed, pending
    details JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## QEMU é›†æˆæ¶æ„

```javascript
// QEMU æœåŠ¡æŠ½è±¡å±‚
class QEMUService {
  constructor() {
    this.runningVMs = new Map() // è¿è¡Œä¸­çš„è™šæ‹Ÿæœºå®ä¾‹
    this.qmpSockets = new Map() // QMP ç›‘æ§å¥—æ¥å­—
  }

  // åˆ›å»ºè™šæ‹Ÿæœº
  async createVM(vmConfig) {
    const qemuArgs = this.buildQEMUArgs(vmConfig)
    const vmProcess = spawn('qemu-system-x86_64', qemuArgs)

    this.runningVMs.set(vmConfig.id, vmProcess)
    this.setupQMPConnection(vmConfig.id)

    return vmProcess
  }

  // æ„å»º QEMU å‚æ•°
  buildQEMUArgs(config) {
    return [
      '-m',
      `${config.memory}M`,
      '-smp',
      `cores=${config.cpu}`,
      '-hda',
      config.diskPath,
      '-netdev',
      'user,id=net0',
      '-device',
      'e1000,netdev=net0',
      '-vnc',
      `:${config.vncPort}`,
      '-qmp',
      `unix:${config.qmpSocket},server,nowait`,
      config.cdrom ? ['-cdrom', config.cdrom] : [],
    ]
      .flat()
      .filter(Boolean)
  }

  // QMP ç›‘æ§è¿æ¥
  setupQMPConnection(vmId) {
    // é€šè¿‡ QMP åè®®ç›‘æ§è™šæ‹ŸæœºçŠ¶æ€
    // è·å– CPUã€å†…å­˜ã€ç½‘ç»œä½¿ç”¨æƒ…å†µ
  }
}
```

## å®æ—¶é€šä¿¡æ¶æ„

```javascript
// WebSocket æœåŠ¡
class WebSocketService {
  constructor(server) {
    this.io = socketIO(server, {
      cors: { origin: '*' },
    })

    this.setupEventHandlers()
  }

  setupEventHandlers() {
    this.io.on('connection', socket => {
      // ç”¨æˆ·è®¤è¯
      socket.on('authenticate', async token => {
        const user = await this.verifyToken(token)
        socket.userId = user.id
        socket.join(`user:${user.id}`)
      })

      // è®¢é˜…è™šæ‹ŸæœºçŠ¶æ€
      socket.on('subscribe:vm', vmId => {
        socket.join(`vm:${vmId}`)
      })

      // è™šæ‹Ÿæœºæ“ä½œ
      socket.on('vm:start', async vmId => {
        try {
          await VMService.startVM(vmId)
          this.io.to(`vm:${vmId}`).emit('vm:status', {
            vmId,
            status: 'starting',
          })
        } catch (error) {
          socket.emit('error', error.message)
        }
      })
    })
  }

  // å¹¿æ’­è™šæ‹ŸæœºçŠ¶æ€æ›´æ–°
  broadcastVMStatus(vmId, status, metrics) {
    this.io.to(`vm:${vmId}`).emit('vm:status', {
      vmId,
      status,
      metrics,
      timestamp: new Date().toISOString(),
    })
  }
}
```

## å®‰å…¨æ¶æ„

```javascript
// å®‰å…¨ä¸­é—´ä»¶
const securityMiddleware = {
  // JWT è®¤è¯
  authenticate: async (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1]
    const user = await supabase.auth.getUser(token)
    req.user = user
    next()
  },

  // æƒé™æ£€æŸ¥
  authorize: permissions => {
    return (req, res, next) => {
      if (!req.user.permissions.includes(permissions)) {
        return res.status(403).json({ error: 'Forbidden' })
      }
      next()
    }
  },

  // èµ„æºè®¿é—®æ§åˆ¶
  checkVMOwnership: async (req, res, next) => {
    const vmId = req.params.id
    const vm = await VMService.getVM(vmId)

    if (vm.user_id !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Access denied' })
    }
    next()
  },

  // é™æµ
  rateLimit: rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: 'Too many requests from this IP',
  }),

  // è¾“å…¥éªŒè¯å’Œæ¸…ç†
  validateInput: schema => {
    return (req, res, next) => {
      const { error, value } = schema.validate(req.body)
      if (error) {
        return res.status(400).json({ error: error.details[0].message })
      }
      req.body = value
      next()
    }
  },

  // CSRF ä¿æŠ¤
  csrfProtection: csrf({
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    },
  }),
}
```

## ç›‘æ§ä¸æ—¥å¿—æ¶æ„

```javascript
// ç›‘æ§æœåŠ¡
class MonitoringService {
  constructor() {
    this.metrics = new Map()
    this.startMetricsCollection()
  }

  // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
  async collectSystemMetrics() {
    return {
      cpu: await this.getCPUUsage(),
      memory: await this.getMemoryUsage(),
      disk: await this.getDiskUsage(),
      network: await this.getNetworkStats(),
      timestamp: new Date().toISOString(),
    }
  }

  // æ”¶é›†è™šæ‹ŸæœºæŒ‡æ ‡
  async collectVMMetrics(vmId) {
    const vm = this.runningVMs.get(vmId)
    if (!vm) return null

    try {
      // é€šè¿‡ QMP åè®®è·å–è™šæ‹ŸæœºæŒ‡æ ‡
      const qmpClient = this.qmpSockets.get(vmId)
      const metrics = await qmpClient.query({
        execute: 'query-status',
      })

      return {
        vmId,
        status: metrics.status,
        cpu: await this.getVMCPUUsage(vmId),
        memory: await this.getVMMemoryUsage(vmId),
        disk: await this.getVMDiskUsage(vmId),
        network: await this.getVMNetworkStats(vmId),
        timestamp: new Date().toISOString(),
      }
    } catch (error) {
      logger.error(`Failed to collect metrics for VM ${vmId}:`, error)
      return null
    }
  }

  // å¯åŠ¨æŒ‡æ ‡æ”¶é›†å®šæ—¶ä»»åŠ¡
  startMetricsCollection() {
    // æ¯30ç§’æ”¶é›†ä¸€æ¬¡ç³»ç»ŸæŒ‡æ ‡
    cron.schedule('*/30 * * * * *', async () => {
      const metrics = await this.collectSystemMetrics()
      await this.storeMetrics('system', metrics)
    })

    // æ¯15ç§’æ”¶é›†ä¸€æ¬¡è™šæ‹ŸæœºæŒ‡æ ‡
    cron.schedule('*/15 * * * * *', async () => {
      for (const vmId of this.runningVMs.keys()) {
        const metrics = await this.collectVMMetrics(vmId)
        if (metrics) {
          await this.storeMetrics('vm', metrics)
          // é€šè¿‡ WebSocket å¹¿æ’­å®æ—¶æŒ‡æ ‡
          wsService.broadcastVMMetrics(vmId, metrics)
        }
      }
    })
  }

  // å­˜å‚¨æŒ‡æ ‡åˆ°æ•°æ®åº“
  async storeMetrics(type, metrics) {
    try {
      if (type === 'vm') {
        await supabase.from('vm_metrics').insert({
          vm_id: metrics.vmId,
          cpu_usage: metrics.cpu,
          memory_usage: metrics.memory,
          disk_usage: metrics.disk,
          network_in_bytes: metrics.network.in,
          network_out_bytes: metrics.network.out,
          timestamp: metrics.timestamp,
        })
      }
    } catch (error) {
      logger.error('Failed to store metrics:', error)
    }
  }
}

// æ—¥å¿—æœåŠ¡
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'voidVM' },
  transports: [
    // é”™è¯¯æ—¥å¿—å†™å…¥æ–‡ä»¶
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
    }),
    // æ‰€æœ‰æ—¥å¿—å†™å…¥æ–‡ä»¶
    new winston.transports.File({
      filename: 'logs/combined.log',
    }),
    // å¼€å‘ç¯å¢ƒè¾“å‡ºåˆ°æ§åˆ¶å°
    ...(process.env.NODE_ENV !== 'production'
      ? [
          new winston.transports.Console({
            format: winston.format.simple(),
          }),
        ]
      : []),
  ],
})
```

## ç¼“å­˜æ¶æ„

```javascript
// Redis ç¼“å­˜æœåŠ¡
class CacheService {
  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379,
      password: process.env.REDIS_PASSWORD,
      db: 0,
    })
  }

  // ç¼“å­˜è™šæ‹ŸæœºçŠ¶æ€
  async cacheVMStatus(vmId, status, ttl = 300) {
    const key = `vm:status:${vmId}`
    await this.redis.setex(key, ttl, JSON.stringify(status))
  }

  // è·å–ç¼“å­˜çš„è™šæ‹ŸæœºçŠ¶æ€
  async getCachedVMStatus(vmId) {
    const key = `vm:status:${vmId}`
    const cached = await this.redis.get(key)
    return cached ? JSON.parse(cached) : null
  }

  // ç¼“å­˜ç”¨æˆ·ä¼šè¯
  async cacheUserSession(userId, sessionData, ttl = 3600) {
    const key = `session:${userId}`
    await this.redis.setex(key, ttl, JSON.stringify(sessionData))
  }

  // æ¸…é™¤è™šæ‹Ÿæœºç›¸å…³ç¼“å­˜
  async clearVMCache(vmId) {
    const pattern = `vm:*:${vmId}`
    const keys = await this.redis.keys(pattern)
    if (keys.length > 0) {
      await this.redis.del(...keys)
    }
  }
}
```

## éƒ¨ç½²æ¶æ„

```yaml
# docker-compose.yml
version: '3.8'

services:
  # å‰ç«¯æœåŠ¡
  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile
    ports:
      - '3000:80'
    environment:
      - VITE_API_URL=http://localhost:5000
      - VITE_SUPABASE_URL=${SUPABASE_URL}
      - VITE_SUPABASE_ANON_KEY=${SUPABASE_ANON_KEY}
    depends_on:
      - backend

  # åç«¯æœåŠ¡
  backend:
    build:
      context: ./server
      dockerfile: Dockerfile
    ports:
      - '5000:5000'
    environment:
      - NODE_ENV=production
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_SERVICE_KEY=${SUPABASE_SERVICE_KEY}
      - REDIS_HOST=redis
    volumes:
      - /var/lib/libvirt:/var/lib/libvirt
      - /dev/kvm:/dev/kvm
    privileged: true
    depends_on:
      - redis
      - postgres

  # Redis ç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes

  # PostgreSQL (å¤‡ç”¨ï¼Œä¸»è¦ä½¿ç”¨ Supabase)
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=voidvm
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - '5432:5432'

  # Nginx åå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  redis_data:
  postgres_data:
```

## æ€§èƒ½ä¼˜åŒ–æ¶æ„

```javascript
// æ€§èƒ½ä¼˜åŒ–æœåŠ¡
class PerformanceService {
  constructor() {
    this.vmQueue = new Queue('vm-operations', {
      redis: {
        host: process.env.REDIS_HOST,
        port: process.env.REDIS_PORT,
      },
    })

    this.setupQueueProcessors()
  }

  // è®¾ç½®é˜Ÿåˆ—å¤„ç†å™¨
  setupQueueProcessors() {
    // è™šæ‹Ÿæœºå¯åŠ¨é˜Ÿåˆ—
    this.vmQueue.process('start-vm', 5, async job => {
      const { vmId, userId } = job.data
      return await VMService.startVM(vmId, userId)
    })

    // è™šæ‹Ÿæœºåœæ­¢é˜Ÿåˆ—
    this.vmQueue.process('stop-vm', 10, async job => {
      const { vmId, userId } = job.data
      return await VMService.stopVM(vmId, userId)
    })

    // é•œåƒæ„å»ºé˜Ÿåˆ—
    this.vmQueue.process('build-image', 2, async job => {
      const { imageConfig } = job.data
      return await ImageService.buildImage(imageConfig)
    })
  }

  // å¼‚æ­¥æ‰§è¡Œè™šæ‹Ÿæœºæ“ä½œ
  async queueVMOperation(operation, vmId, userId) {
    const job = await this.vmQueue.add(
      `${operation}-vm`,
      {
        vmId,
        userId,
        timestamp: new Date().toISOString(),
      },
      {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      }
    )

    return job.id
  }

  // è¿æ¥æ± ç®¡ç†
  setupConnectionPool() {
    // æ•°æ®åº“è¿æ¥æ± 
    this.dbPool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    })

    // QEMU è¿›ç¨‹æ± 
    this.qemuPool = new Map()
  }
}
```

## ç¾éš¾æ¢å¤æ¶æ„

```javascript
// å¤‡ä»½æ¢å¤æœåŠ¡
class BackupService {
  constructor() {
    this.setupScheduledBackups()
  }

  // è™šæ‹Ÿæœºå¿«ç…§
  async createVMSnapshot(vmId, snapshotName) {
    try {
      logger.info(`Creating snapshot ${snapshotName} for VM ${vmId}`)

      const vm = await VMService.getVM(vmId)
      const qmpClient = this.qmpSockets.get(vmId)

      // åˆ›å»ºå†…å­˜å¿«ç…§
      await qmpClient.execute('savevm', {
        name: snapshotName,
      })

      // åˆ›å»ºç£ç›˜å¿«ç…§
      await this.createDiskSnapshot(vm.disk_path, snapshotName)

      // è®°å½•å¿«ç…§ä¿¡æ¯
      await supabase.from('vm_snapshots').insert({
        vm_id: vmId,
        name: snapshotName,
        type: 'full',
        created_at: new Date().toISOString(),
      })

      logger.info(`Snapshot ${snapshotName} created successfully`)
      return true
    } catch (error) {
      logger.error(`Failed to create snapshot: ${error.message}`)
      throw error
    }
  }

  // æ¢å¤è™šæ‹Ÿæœºå¿«ç…§
  async restoreVMSnapshot(vmId, snapshotName) {
    try {
      logger.info(`Restoring snapshot ${snapshotName} for VM ${vmId}`)

      // åœæ­¢è™šæ‹Ÿæœº
      await VMService.stopVM(vmId)

      // æ¢å¤ç£ç›˜
      await this.restoreDiskSnapshot(vmId, snapshotName)

      // å¯åŠ¨è™šæ‹Ÿæœºå¹¶åŠ è½½å†…å­˜å¿«ç…§
      await VMService.startVM(vmId)
      const qmpClient = this.qmpSockets.get(vmId)
      await qmpClient.execute('loadvm', {
        name: snapshotName,
      })

      logger.info(`Snapshot ${snapshotName} restored successfully`)
      return true
    } catch (error) {
      logger.error(`Failed to restore snapshot: ${error.message}`)
      throw error
    }
  }

  // å®šæ—¶å¤‡ä»½
  setupScheduledBackups() {
    // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œè‡ªåŠ¨å¤‡ä»½
    cron.schedule('0 2 * * *', async () => {
      const runningVMs = await VMService.getRunningVMs()

      for (const vm of runningVMs) {
        try {
          const snapshotName = `auto_${new Date().toISOString().split('T')[0]}`
          await this.createVMSnapshot(vm.id, snapshotName)
        } catch (error) {
          logger.error(`Auto backup failed for VM ${vm.id}: ${error.message}`)
        }
      }
    })
  }
}
```

## API è®¾è®¡è§„èŒƒ

```javascript
// RESTful API è®¾è®¡
const apiRoutes = {
    // è™šæ‹Ÿæœºç®¡ç†
    'GET /api/v1/vms': 'List all VMs for authenticated user',
    'POST /api/v1/vms': 'Create a new VM',
    'GET /api/v1/vms/:id': 'Get VM details',
    'PUT /api/v1/vms/:id': 'Update VM configuration',
    'DELETE /api/v1/vms/:id': 'Delete VM',

    // è™šæ‹Ÿæœºæ“ä½œ
    'POST /api/v1/vms/:id/start': 'Start VM',
    'POST /api/v1/vms/:id/stop': 'Stop VM',
    'POST /api/v1/vms/:id/pause': 'Pause VM',
    'POST /api/v1/vms/:id/resume': 'Resume VM',
    'POST /api/v1/vms/:id/reset': 'Reset VM',

    // å¿«ç…§ç®¡ç†
    'GET /api/v1/vms/:id/snapshots': 'List VM snapshots',
    'POST /api/v1/vms/:id/snapshots': 'Create VM snapshot',
    'POST /api/v1/vms/:id/snapshots/:name/restore': 'Restore snapshot',
    'DELETE /api/v1/vms/:id/snapshots/:name
    'DELETE /api/v1/vms/:id/snapshots/:name': 'Delete snapshot',

    // ç›‘æ§å’ŒæŒ‡æ ‡
    'GET /api/v1/vms/:id/metrics': 'Get VM performance metrics',
    'GET /api/v1/vms/:id/console': 'Get VM console access',
    'GET /api/v1/vms/:id/logs': 'Get VM operation logs',

    // é•œåƒç®¡ç†
    'GET /api/v1/images': 'List available VM images',
    'POST /api/v1/images': 'Upload new VM image',
    'GET /api/v1/images/:id': 'Get image details',
    'DELETE /api/v1/images/:id': 'Delete VM image',

    // ç½‘ç»œç®¡ç†
    'GET /api/v1/networks': 'List virtual networks',
    'POST /api/v1/networks': 'Create virtual network',
    'GET /api/v1/networks/:id': 'Get network details',
    'PUT /api/v1/networks/:id': 'Update network configuration',
    'DELETE /api/v1/networks/:id': 'Delete virtual network',

    // å­˜å‚¨ç®¡ç†
    'GET /api/v1/storage': 'List storage pools',
    'POST /api/v1/storage': 'Create storage pool',
    'GET /api/v1/storage/:id/volumes': 'List volumes in storage pool',
    'POST /api/v1/storage/:id/volumes': 'Create new volume',

    // ç”¨æˆ·ç®¡ç†
    'GET /api/v1/users/profile': 'Get user profile',
    'PUT /api/v1/users/profile': 'Update user profile',
    'GET /api/v1/users/usage': 'Get resource usage statistics',

    // ç³»ç»Ÿç®¡ç†
    'GET /api/v1/system/stats': 'Get system statistics',
    'GET /api/v1/system/health': 'Health check endpoint',
    'GET /api/v1/system/version': 'Get system version info'
};

// API å“åº”æ ¼å¼æ ‡å‡†
const ApiResponse = {
    success: {
        code: 200,
        message: 'Success',
        data: {},
        timestamp: new Date().toISOString()
    },
    error: {
        code: 400,
        message: 'Error message',
        error: 'Detailed error information',
        timestamp: new Date().toISOString()
    }
};
```

## æ‰©å±•æ€§æ¶æ„

```javascript
// å¾®æœåŠ¡æ¶æ„æ‰©å±•
class MicroserviceArchitecture {
  constructor() {
    this.services = new Map()
    this.serviceRegistry = new ServiceRegistry()
    this.loadBalancer = new LoadBalancer()
  }

  // æœåŠ¡æ³¨å†Œ
  registerService(serviceName, serviceInstance) {
    this.services.set(serviceName, serviceInstance)
    this.serviceRegistry.register(serviceName, serviceInstance)
  }

  // æœåŠ¡å‘ç°
  async discoverService(serviceName) {
    return await this.serviceRegistry.discover(serviceName)
  }

  // è´Ÿè½½å‡è¡¡
  async routeRequest(serviceName, request) {
    const serviceInstances = await this.discoverService(serviceName)
    const selectedInstance = this.loadBalancer.select(serviceInstances)
    return await selectedInstance.handleRequest(request)
  }
}

// æœåŠ¡æ³¨å†Œä¸­å¿ƒ
class ServiceRegistry {
  constructor() {
    this.services = new Map()
    this.healthChecker = new HealthChecker()
  }

  register(serviceName, instance) {
    if (!this.services.has(serviceName)) {
      this.services.set(serviceName, [])
    }
    this.services.get(serviceName).push(instance)

    // å¯åŠ¨å¥åº·æ£€æŸ¥
    this.healthChecker.monitor(instance)
  }

  async discover(serviceName) {
    const instances = this.services.get(serviceName) || []
    // è¿”å›å¥åº·çš„æœåŠ¡å®ä¾‹
    return instances.filter(instance => instance.isHealthy)
  }
}

// å®¹å™¨åŒ–æ‰©å±•
class ContainerOrchestration {
  constructor() {
    this.docker = new Docker()
    this.kubernetes = new KubernetesClient()
  }

  // Docker å®¹å™¨ç®¡ç†
  async deployService(serviceName, config) {
    const container = await this.docker.createContainer({
      Image: config.image,
      name: serviceName,
      Env: config.environment,
      PortBindings: config.ports,
      RestartPolicy: { Name: 'unless-stopped' },
    })

    await container.start()
    return container
  }

  // Kubernetes éƒ¨ç½²
  async deployToK8s(serviceName, manifest) {
    await this.kubernetes.apply(manifest)
    return await this.kubernetes.waitForDeployment(serviceName)
  }
}
```

## å®‰å…¨åŠ å›ºæ¶æ„

```javascript
// å®‰å…¨æœåŠ¡
class SecurityService {
  constructor() {
    this.setupSecurityPolicies()
    this.auditLogger = new AuditLogger()
  }

  // è®¾ç½®å®‰å…¨ç­–ç•¥
  setupSecurityPolicies() {
    // å¯†ç ç­–ç•¥
    this.passwordPolicy = {
      minLength: 8,
      requireUppercase: true,
      requireLowercase: true,
      requireNumbers: true,
      requireSpecialChars: true,
      maxAge: 90, // days
    }

    // ä¼šè¯ç­–ç•¥
    this.sessionPolicy = {
      maxAge: 3600, // 1 hour
      maxConcurrentSessions: 5,
      requireMFA: false,
    }

    // è®¿é—®æ§åˆ¶ç­–ç•¥
    this.accessPolicy = {
      maxFailedAttempts: 5,
      lockoutDuration: 1800, // 30 minutes
      allowedIPs: [], // empty = allow all
      blockedIPs: [],
    }
  }

  // å¤šå› ç´ è®¤è¯
  async setupMFA(userId, method = 'totp') {
    const secret = authenticator.generateSecret()
    const qrCode = await QRCode.toDataURL(authenticator.keyuri(userId, 'voidVM', secret))

    await supabase.from('user_mfa').insert({
      user_id: userId,
      method,
      secret: this.encrypt(secret),
      enabled: false,
    })

    return { secret, qrCode }
  }

  // éªŒè¯ MFA
  async verifyMFA(userId, token) {
    const mfaRecord = await supabase
      .from('user_mfa')
      .select('secret')
      .eq('user_id', userId)
      .single()

    if (!mfaRecord) {
      throw new Error('MFA not configured')
    }

    const secret = this.decrypt(mfaRecord.secret)
    return authenticator.verify({ token, secret })
  }

  // å®¡è®¡æ—¥å¿—
  async logSecurityEvent(event) {
    await this.auditLogger.log({
      type: 'security',
      event: event.type,
      userId: event.userId,
      ip: event.ip,
      userAgent: event.userAgent,
      details: event.details,
      timestamp: new Date().toISOString(),
    })
  }

  // åŠ å¯†è§£å¯†
  encrypt(text) {
    const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    return encrypted
  }

  decrypt(encryptedText) {
    const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    return decrypted
  }
}
```

## æµ‹è¯•æ¶æ„

```javascript
// æµ‹è¯•æ¡†æ¶
describe('voidVM Test Suite', () => {
  // å•å…ƒæµ‹è¯•
  describe('Unit Tests', () => {
    describe('VM Service', () => {
      it('should create a new VM', async () => {
        const vmConfig = {
          name: 'test-vm',
          cpu: 2,
          memory: 2048,
          disk: 20,
        }

        const vm = await VMService.createVM(vmConfig)
        expect(vm).to.have.property('id')
        expect(vm.name).to.equal('test-vm')
      })

      it('should start a VM', async () => {
        const vmId = 'test-vm-id'
        const result = await VMService.startVM(vmId)
        expect(result).to.be.true
      })
    })

    describe('QEMU Service', () => {
      it('should build correct QEMU arguments', () => {
        const config = {
          memory: 2048,
          cpu: 2,
          diskPath: '/path/to/disk.qcow2',
        }

        const args = QEMUService.buildQEMUArgs(config)
        expect(args).to.include('-m')
        expect(args).to.include('2048M')
      })
    })
  })

  // é›†æˆæµ‹è¯•
  describe('Integration Tests', () => {
    describe('API Endpoints', () => {
      it('should create VM via API', async () => {
        const response = await request(app)
          .post('/api/v1/vms')
          .set('Authorization', `Bearer ${testToken}`)
          .send({
            name: 'integration-test-vm',
            cpu: 1,
            memory: 1024,
          })

        expect(response.status).to.equal(201)
        expect(response.body.data).to.have.property('id')
      })
    })

    describe('Database Operations', () => {
      it('should store VM configuration', async () => {
        const vm = await VMService.createVM(testVMConfig)
        const stored = await supabase.from('virtual_machines').select('*').eq('id', vm.id).single()

        expect(stored.data).to.not.be.null
      })
    })
  })

  // ç«¯åˆ°ç«¯æµ‹è¯•
  describe('E2E Tests', () => {
    describe('VM Lifecycle', () => {
      it('should complete full VM lifecycle', async () => {
        // åˆ›å»ºè™šæ‹Ÿæœº
        const vm = await VMService.createVM(testVMConfig)

        // å¯åŠ¨è™šæ‹Ÿæœº
        await VMService.startVM(vm.id)
        expect(await VMService.getVMStatus(vm.id)).to.equal('running')

        // åœæ­¢è™šæ‹Ÿæœº
        await VMService.stopVM(vm.id)
        expect(await VMService.getVMStatus(vm.id)).to.equal('stopped')

        // åˆ é™¤è™šæ‹Ÿæœº
        await VMService.deleteVM(vm.id)
        const deleted = await VMService.getVM(vm.id)
        expect(deleted).to.be.null
      })
    })
  })

  // æ€§èƒ½æµ‹è¯•
  describe('Performance Tests', () => {
    it('should handle concurrent VM operations', async () => {
      const promises = []
      const vmCount = 10

      for (let i = 0; i < vmCount; i++) {
        promises.push(
          VMService.createVM({
            name: `perf-test-vm-${i}`,
            cpu: 1,
            memory: 512,
          })
        )
      }

      const results = await Promise.all(promises)
      expect(results).to.have.length(vmCount)
    })

    it('should respond to API requests within acceptable time', async () => {
      const start = Date.now()

      await request(app).get('/api/v1/vms').set('Authorization', `Bearer ${testToken}`)

      const duration = Date.now() - start
      expect(duration).to.be.below(1000) // less than 1 second
    })
  })
})
```

## é…ç½®ç®¡ç†æ¶æ„

```javascript
// é…ç½®ç®¡ç†
class ConfigManager {
  constructor() {
    this.configs = new Map()
    this.loadConfigurations()
  }

  loadConfigurations() {
    // åº”ç”¨é…ç½®
    this.configs.set('app', {
      name: 'voidVM',
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      port: process.env.PORT || 5000,
      host: process.env.HOST || 'localhost',
    })

    // æ•°æ®åº“é…ç½®
    this.configs.set('database', {
      supabase: {
        url: process.env.SUPABASE_URL,
        anonKey: process.env.SUPABASE_ANON_KEY,
        serviceKey: process.env.SUPABASE_SERVICE_KEY,
      },
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: process.env.REDIS_PORT || 6379,
        password: process.env.REDIS_PASSWORD,
      },
    })

    // QEMU é…ç½®
    this.configs.set('qemu', {
      binaryPath: process.env.QEMU_BINARY || '/usr/bin/qemu-system-x86_64',
      imagePath: process.env.VM_IMAGE_PATH || '/var/lib/voidvm/images',
      maxConcurrentVMs: process.env.MAX_CONCURRENT_VMS || 10,
      defaultMemory: 1024,
      defaultCPU: 1,
      vncPortRange: {
        start: 5900,
        end: 5999,
      },
    })

    // å®‰å…¨é…ç½®
    this.configs.set('security', {
      jwtSecret: process.env.JWT_SECRET,
      encryptionKey: process.env.ENCRYPTION_KEY,
      sessionTimeout: 3600,
      maxLoginAttempts: 5,
      lockoutDuration: 1800,
    })

    // ç›‘æ§é…ç½®
    this.configs.set('monitoring', {
      metricsInterval: 30000, // 30 seconds
      logLevel: process.env.LOG_LEVEL || 'info',
      enableMetrics: process.env.ENABLE_METRICS !== 'false',
      alertingEnabled: process.env.ALERTING_ENABLED === 'true',
    })
  }

  get(configName, key = null) {
    const config = this.configs.get(configName)
    if (!config) {
      throw new Error(`Configuration '${configName}' not found`)
    }

    return key ? config[key] : config
  }

  validate() {
    const required = [
      'SUPABASE_URL',
      'SUPABASE_ANON_KEY',
      'SUPABASE_SERVICE_KEY',
      'JWT_SECRET',
      'ENCRYPTION_KEY',
    ]

    const missing = required.filter(key => !process.env[key])

    if (missing.length > 0) {
      throw new Error(`Missing required environment variables: ${missing.join(', ')}`)
    }

    // éªŒè¯ QEMU äºŒè¿›åˆ¶æ–‡ä»¶å­˜åœ¨
    if (!fs.existsSync(this.get('qemu', 'binaryPath'))) {
      throw new Error('QEMU binary not found at specified path')
    }

    // éªŒè¯é•œåƒç›®å½•å­˜åœ¨æˆ–åˆ›å»º
    const imagePath = this.get('qemu', 'imagePath')
    if (!fs.existsSync(imagePath)) {
      fs.mkdirSync(imagePath, { recursive: true })
    }

    return true
  }
}
```

## æ•°æ®æµæ¶æ„

<MermaidZoom>

```mermaid
graph TD
    A[ç”¨æˆ·ç•Œé¢ Vue] --> B[API Gateway Express]
    B --> C{è®¤è¯ä¸­é—´ä»¶}
    C -->|è®¤è¯å¤±è´¥| D[è¿”å›401é”™è¯¯]
    C -->|è®¤è¯æˆåŠŸ| E[ä¸šåŠ¡é€»è¾‘å±‚]

    E --> F[VM Service]
    E --> G[Auth Service]
    E --> H[Monitoring Service]

    F --> I[QEMU Manager]
    F --> J[Supabase DB]
    F --> K[Redis Cache]

    I --> L[QEMU Process]
    I --> M[QMP Socket]

    H --> N[Metrics Collector]
    N --> O[WebSocket Server]
    O --> A

    J --> P[PostgreSQL]
    K --> Q[å†…å­˜ç¼“å­˜]

    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style E fill:#e8f5e8
    style I fill:#fff3e0
    style J fill:#fce4ec
```

</MermaidZoom>

## é”™è¯¯å¤„ç†æ¶æ„

```javascript
// ç»Ÿä¸€é”™è¯¯å¤„ç†
class ErrorHandler {
  constructor() {
    this.errorTypes = {
      VALIDATION_ERROR: 'ValidationError',
      AUTHENTICATION_ERROR: 'AuthenticationError',
      AUTHORIZATION_ERROR: 'AuthorizationError',
      RESOURCE_NOT_FOUND: 'ResourceNotFoundError',
      QEMU_ERROR: 'QEMUError',
      DATABASE_ERROR: 'DatabaseError',
      NETWORK_ERROR: 'NetworkError',
      SYSTEM_ERROR: 'SystemError',
    }
  }

  // åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±»
  createError(type, message, details = {}) {
    const error = new Error(message)
    error.name = type
    error.details = details
    error.timestamp = new Date().toISOString()
    return error
  }

  // Express é”™è¯¯å¤„ç†ä¸­é—´ä»¶
  expressErrorHandler() {
    return (err, req, res, next) => {
      // è®°å½•é”™è¯¯
      logger.error({
        error: err.message,
        stack: err.stack,
        url: req.url,
        method: req.method,
        userId: req.user?.id,
        timestamp: new Date().toISOString(),
      })

      // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ä¸åŒçš„å“åº”
      let statusCode = 500
      let message = 'Internal Server Error'

      switch (err.name) {
        case this.errorTypes.VALIDATION_ERROR:
          statusCode = 400
          message = err.message
          break
        case this.errorTypes.AUTHENTICATION_ERROR:
          statusCode = 401
          message = 'Authentication required'
          break
        case this.errorTypes.AUTHORIZATION_ERROR:
          statusCode = 403
          message = 'Access denied'
          break
        case this.errorTypes.RESOURCE_NOT_FOUND:
          statusCode = 404
          message = err.message || 'Resource not found'
          break
        case this.errorTypes.QEMU_ERROR:
          statusCode = 500
          message = 'Virtual machine operation failed'
          break
      }

      res.status(statusCode).json({
        error: true,
        message,
        code: err.name,
        details: process.env.NODE_ENV === 'development' ? err.details : undefined,
        timestamp: new Date().toISOString(),
      })
    }
  }

  // å¼‚æ­¥æ“ä½œé”™è¯¯å¤„ç†
  asyncWrapper(fn) {
    return (req, res, next) => {
      Promise.resolve(fn(req, res, next)).catch(next)
    }
  }

  // QEMU é”™è¯¯å¤„ç†
  handleQEMUError(error, vmId) {
    const qemuError = this.createError(
      this.errorTypes.QEMU_ERROR,
      `QEMU operation failed for VM ${vmId}`,
      {
        vmId,
        originalError: error.message,
        stderr: error.stderr,
      }
    )

    logger.error('QEMU Error:', qemuError)
    return qemuError
  }
}
```
